<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 放飞梦想]]></title>
  <link href="http://mogoweb.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://mogoweb.net/"/>
  <updated>2015-11-18T08:43:00+08:00</updated>
  <id>http://mogoweb.net/</id>
  <author>
    <name><![CDATA[mogoweb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android源码阅读与理解（二）：Android系统Build流程详解]]></title>
    <link href="http://mogoweb.net/blog/2015/11/17/android-system-building-flow/"/>
    <updated>2015-11-17T08:51:50+08:00</updated>
    <id>http://mogoweb.net/blog/2015/11/17/android-system-building-flow</id>
    <content type="html"><![CDATA[<p>个人认为，成为一个靠谱的Android系统工程师，必须具备以下技能：</p>

<ul>
<li>翻墙</li>
<li>会使用Linux系统</li>
<li>阅读英文资料</li>
</ul>


<p>翻墙技能就不用说了，因为不翻墙，Android源码难以获取，更不用谈体验墙外精彩的世界了。关于第二点，最好的Android系统开发环境就是Linux（推荐ubuntu），如果能够熟练使用Linux系统可以节省不少折腾环境的时间。最后英文阅读能力也很关键，因为碰到问题Google, <a href="http://www.stackoverflow.com">StackOverflow</a>非常有用，上面的回答有不少是用英文写的。</p>

<p>在这里略过下载Android源码，最好的方法是参考<a href="http://source.android.com">官方文档</a>。简单说一下我的环境：</p>

<ul>
<li>Ubuntu 14.04 LTS 64位</li>
<li>Android 4.4.2源码</li>
<li>Sublime Text 2</li>
<li>Intel&reg; Core&trade; i7-2630QM CPU @ 2.00GHz, 8G RAM, 1TB hd</li>
</ul>


<p>源码下载后，执行如下命令即可编译Android系统(后面的文章将使用$ANDROID_SRC指代Android源码所在目录，如非特别指明，假设命令行在Android源码目录下执行):</p>

<ol>
<li>source build/envsetup.sh</li>
<li>lunch</li>
<li>make -j4</li>
</ol>


<p>下面就解析以上三个步骤分别做了什么事情。</p>

<h2>设置环境变量</h2>

<p>打开$ANDROID_SRC/build/envsetup.sh文件，我们可以看到文件中定义了一些shell函数，其作用是初始化编译环境，并引入一些辅助的Shell函数，这其中就包括第二步使用lunch函数。这些shell函数可以看做shell命令，方便我们进行一些build任务，比如常用的mm。下面就列出一些常用的函数：</p>

<p><strong>表 1. build/envsetup.sh 中定义的常用函数</strong></p>

<hr />

<table>
<thead>
<tr>
<th style="text-align:left;"> <strong>名称</strong> </th>
<th style="text-align:left;"> <strong>说明</strong> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">lunch          </td>
<td style="text-align:left;"> 选择产品，格式为lunch BUILDID-BUILDTYPE，如果不指定，会弹出一个列表选择 </td>
</tr>
<tr>
<td style="text-align:left;">tapas          </td>
<td style="text-align:left;"> build未打包到image的app，命令行后可以跟一个或者多个app的名称</td>
</tr>
<tr>
<td style="text-align:left;">croot          </td>
<td style="text-align:left;"> 切换到源码树的根目录 </td>
</tr>
<tr>
<td style="text-align:left;">m              </td>
<td style="text-align:left;"> 在源码树的根目录执行 make </td>
</tr>
<tr>
<td style="text-align:left;">mm             </td>
<td style="text-align:left;"> Build 当前目录下的模块 </td>
</tr>
<tr>
<td style="text-align:left;">mmm                </td>
<td style="text-align:left;"> Build 指定目录下的模块 </td>
</tr>
<tr>
<td style="text-align:left;">mma            </td>
<td style="text-align:left;"> Build 当前目录下的模块及所有依赖的模块 </td>
</tr>
<tr>
<td style="text-align:left;">mmma           </td>
<td style="text-align:left;"> Build 指定目录下的模块及所有依赖的模块 </td>
</tr>
<tr>
<td style="text-align:left;">cgrep          </td>
<td style="text-align:left;"> 在所有 C/C++ 文件上执行 grep </td>
</tr>
<tr>
<td style="text-align:left;">jgrep          </td>
<td style="text-align:left;"> 在所有 Java 文件上执行 grep </td>
</tr>
<tr>
<td style="text-align:left;">resgrep        </td>
<td style="text-align:left;"> 在所有 res/*.xml 文件上执行 grep </td>
</tr>
<tr>
<td style="text-align:left;">godir          </td>
<td style="text-align:left;"> 转到包含某个文件的目录路径 </td>
</tr>
<tr>
<td style="text-align:left;">printconfig    </td>
<td style="text-align:left;"> 显示当前 Build 的配置信息 </td>
</tr>
<tr>
<td style="text-align:left;">add_lunch_combo</td>
<td style="text-align:left;"> 在 lunch 函数的菜单中添加一个条目 </td>
</tr>
</tbody>
</table>


<p>除了定义辅助Shell函数，在脚本的结尾处，还会遍历device和vendor目录下的vendorsetup.sh文件，vendorsetup.sh文件定义与设备相关的环境变量，比如<em>/device/generic/armv7-a-neon/vendorsetup.sh</em>就定义了如下：</p>

<blockquote><p>add_lunch_combo mini_armv7a_neon-userdebug</p></blockquote>

<p>这会在lunch菜单中增加一个选项：mini_armv7a_neon-userdebug</p>

<h2>lunch函数详解</h2>

<p>Android支持不同的硬件，比如不同的CPU架构（ARM、MIPS，X86），不同厂商的外设（如蓝牙、wifi、基带等），另外可能还需要分Debug版本和Release版本，这都是在lunch中进行选择的。lunch命令的格式为lunch BUILDID-BUILDTYPE，其中BUILDTYPE取值如下：</p>

<p><strong>表 2. BUILDTYPE说明</strong></p>

<hr />

<table>
<thead>
<tr>
<th style="text-align:left;"> <strong>BUILDTYPE</strong> </th>
<th style="text-align:left;"> <strong>说明</strong> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">user           </td>
<td style="text-align:left;"> 相当于Release版本，无root权限，不打包调试工具，适合最后的产品发布 </td>
</tr>
<tr>
<td style="text-align:left;">userdebug      </td>
<td style="text-align:left;"> 和user类似，但多了root权限，可以调试，适合于产品调试 </td>
</tr>
<tr>
<td style="text-align:left;">eng            </td>
<td style="text-align:left;"> 开发阶段的配置，另外还打包了许多调试工具，适合于产品初期阶段 </td>
</tr>
</tbody>
</table>


<p>BUILDID则是一组特性集合的代码，这个通常与具体的平台相关。除了Android源码预置的选项外，还可以通过add_lunch_combo命令添加自定义的组合。当我们要开发一款新的Android产品时，首先就需要在Build系统中添加对于该产品的定义。</p>

<p>产品定义文件通常位于device目录下，vendor目录已经不建议使用（nexus系列的产品定义就是放在vendor目录）。device目录下通常根据公司名及产品名分为二级目录，比如generic的目录结构如下：</p>

<pre><code> device
   |-- generic
         |-- armv7-a-neon
         |-- common
         |-- goldfish
         |-- mini-emulator-armv7-a-neon
         |-- mini-emulator-mips
         |-- mini-emulator-x86
         |-- mips
         |-- x86
</code></pre>

<p>通常一个产品定义至少包含4个文件：AndroidProducts.mk, BoardConfig.mk, vendorsetup.sh及版本定义文件（文件名不固定）。关于如何添加产品定义，请参考<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/index.html">&lt;&lt;理解 Android Build 系统>></a>一文的<strong>添加新的产品</strong>一节。</p>

<h2>build Android系统</h2>

<p>最后一步执行<em>make -j4</em>才开始真正的进行编译操作，j后面的数字代表同时编译的job数，这个数字可根据CPU核心线程数而定，通常可指定为CPU核心线程的1~2倍，数字越大，代表同时进行编译的任务越多，整个编译过程也会越快，但需要注意过犹不及。如果不指定目标，默认就会使用“droid”目标，build出完整的Android系统镜像。</p>

<p>Android build系统使用了GNU make，这点很让人意外，因为GNU Makefile实在太难编写了，也不易阅读。不过Google的天才工程师进行了模块化、写了很多实用函数，修改/添加起来还算容易。</p>

<h3>Build输出目录结构</h3>

<p>所有的编译产物都将位于 out 目录下，该目录下主要有以下几个子目录：</p>

<ul>
<li>out/host/：该目录下包含了host端的工具和库，例如：emulator，adb，aapt等。</li>
<li>out/target/common/：该目录下包含了针对设备的共用的编译产物，主要是 Java 应用代码和 Java 库。</li>
<li>out/target/product/<em>product_name</em>/：包含了针对特定设备的编译结果以及平台相关的 C/C++ 库和二进制文件。其中，<em>product_name</em>是具体目标设备的名称。</li>
</ul>


<h3>Build生成的镜像文件</h3>

<p>Build 的产物中最重要的是三个镜像文件，它们都位于 out/target/product/<em>product_name</em>/ 目录下。这三个文件是：</p>

<ul>
<li>system.img：包含了 Android OS 的系统文件，库，可执行文件以及预置的应用程序，将被挂载为根分区。</li>
<li>ramdisk.img：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。</li>
<li>userdata.img：将被挂载为 /data，包含了应用程序相关的数据以及和用户相关的数据。</li>
</ul>


<p>另外还有cache.img,启动模拟器时可使用-cache参数来挂载该文件，指定/cache内容。一般来说我们不直接使用userdata.img，而是使用userdata_qemu.data，用来存放用户数据，可读写，android启动后mount到 /data。只有使用-wipe-data参数启动模拟器是时候才会用到userdata.img，它会使用userdata.img的内容覆盖userdata-qemu.img。</p>

<h2>参考文档</h2>

<ol>
<li><a href="http://www.stackoverflow.com">Android官方文档</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/index.html">理解 Android Build 系统</a></li>
<li><a href="http://www.cloudchou.com/android/post-134.html">Android编译系统详解(一)——build/envsetup.sh</a></li>
<li><a href="http://www.devdiv.com/android_-blog-1-1488.html">Android模拟器镜像文件介绍</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android源码阅读与理解（一）：开篇]]></title>
    <link href="http://mogoweb.net/blog/2015/11/13/reading-android-source-preface/"/>
    <updated>2015-11-13T20:36:35+08:00</updated>
    <id>http://mogoweb.net/blog/2015/11/13/reading-android-source-preface</id>
    <content type="html"><![CDATA[<p>作为一个自认为苦逼的程序员，有一阵子曾考虑逃离程序世界，做一个文艺青年。你看，出去旅旅游、读读书、摄个影，没事发个呆，生活该是多么的惬意。反观程序员，每天对着冰冷的机器，有事无事还要加个班。正如一个段子所写：</p>

<blockquote><p>你苦战通宵游戏时，布里斯班的灯鱼已划过珊瑚丛;</p>

<p>你赶场招聘会时，蒙巴萨的小蟹刚溜出渔夫的掌心;</p>

<p>你写程序代码时，布拉格的电车正摇着铃晃过金色夕阳;</p>

<p>你挤进汹涌的食堂时，哥本哈根的街头画家完成了第99幅立体画。</p>

<p>有一些穿高跟鞋走不到的路，有一些喷着香水闻不到的空气，有一些在楼宇里永远碰遇不到的人。</p></blockquote>

<p>但是，看村上春书的《当我谈跑步时我谈些什么》如同嚼蜡，看侯孝贤、王家卫的电影直睡觉之后，我发现其实身上缺少文艺细胞，无事发呆更是让我难受。其实仔细想想，写代码时虽然苦逼，但是当纠出一个苦苦追寻了半个月的bug的时刻，内心还是感觉很爽的。不读村上春树，读读东野圭吾也挺开心的。每天充实的感觉比无所事事更舒服。所以，我还是需要做回自己，做自己喜欢、自己擅长的事情。读到池建强的《是旅行还是长跑》中这样一段话：</p>

<blockquote><p>只要你没有一个强悍的爹，就要先忘掉那些小鱼小蟹，还有珊瑚丛，那些暂时还不属于你，踏踏实实地练习和提升才是王道，为自己规划一个十年的长跑，可以时不时停下来休息一下，低下头汗水就落入尘埃，抬起头就看看夕阳西下，你抹去疲惫，然后继续前行。十年看似很长，但实在很短，十年以后你回头看看，你究竟是成了人中龙凤，还是小鱼小虾，是你认知了世界，还是世界抛弃了你。</p></blockquote>

<p>瞬间引起了共鸣。</p>

<p>闲话扯远了，作为一个国产OS的从业者，一直都从Android系统吸(chao)收(xi)营(yuan)养(ma)。其实我们更想借鉴ios系统，可惜人家不开源，光看表面是做不了神似的。在开发的过程中，也碰到不少问题，零零碎碎读过一些Android的源码，但基本上都是现学现用，缺乏整体的理解。既然做不了文艺青年，那我就来挑战一下Android系统源码吧。当然现在Android源码分析的书和文章也比较多，比如我手头就有邓凡平的《深入理解Android》、杨云君的《Android的设计与实现》和罗升阳的《Android系统源代码情景分析》，网上的文章更是不计其数。但别人分析了也是别人的，买了他们的书，但买不到他们的知识。还是需要亲自深入代码分析，知识才能变成我的。</p>

<p>在后续的学习中，我将结合自身的工作，分析我所感兴趣的部分。Android系统是一个相当庞大的系统，想要深入掌握每个细节，那是一个不可能完成的任务。所以我会略去驱动、linux内核、media等部分，初步计划阅读的部分如下：</p>

<ol>
<li>Android build系统</li>
<li>Android系统启动</li>
<li>Binder原理与实现</li>
<li>Surface系统</li>
<li>Dalvik虚拟机</li>
<li>chromium Webview</li>
</ol>


<p>为了让自己能坚持下去，要求在阅读过程中记笔记，每周至少写一篇博客，梳理一下阅读心得。希望我能够坚持下去并有所得，加油！</p>

<p><strong>[注]</strong> 本文引用的文字出自池建强《MacTalk人生元编程》P.194。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于chromium for android开发Android浏览器]]></title>
    <link href="http://mogoweb.net/blog/2015/11/03/develop-android-browser-base-on-chromium-for-android/"/>
    <updated>2015-11-03T08:39:21+08:00</updated>
    <id>http://mogoweb.net/blog/2015/11/03/develop-android-browser-base-on-chromium-for-android</id>
    <content type="html"><![CDATA[<p>在上一篇文章&lt;&lt; <a href="http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source/">Chromium for Android开源了</a> >>中谈到了Google已经完全开源了Chromium for Android，这样我们就完全可以开发与Chrome for Android媲美的Android浏览器了。通常浏览器的一些新特性和新功能会先出现在Chromium for Android上，稳定后才会出现在Chrome for Android上，如果我们基于Chromium for Android开发浏览器产品，在新特性和新功能方面不会落后于Chrome浏览器.</p>

<p>Chromium开源项目的代码及其庞大，也相当的复杂。对于Android开发人员，特别是UI开发人员来说，没有一个合适的IDE环境，会是一个非常痛苦的事情。我们通常是这样开发的，在sublime text中阅读、修改代码，使用chromium的构建系统build出apk，安装到手机，进行调试。对于native代码来说，这样的开发方式也不会有太多麻烦，因为native部分的代码通常修改很少。但如果主要进行UI的定制，这种开发方式就非常痛苦了。</p>

<p>为了应对这个问题，考虑如下方案：</p>

<ol>
<li>采用Android Studio作为开发环境，从Chromium for Android抽取chrome模块的源码，加入Android project。</li>
<li>native代码在chromium环境中build，作为so加入Android project</li>
<li>基础模块(base, content, net等)在chromium环境build为jar包，加入Android project</li>
<li>content, chrome, ui等模块的资源文件加入Android library project</li>
</ol>


<p>资源文件为什么不能直接都添加到Android project呢？因为命名空间的原因，比如content模块的资源的命名空间为org.chromium.content, chrome模块的资源的命名空间为org.chromium.chrome，所以需要建立不同的Android library project, 指定不同的包名。最后整个项目的结构如下：</p>

<pre><code>browser
  |_ app
  |    |_ libs
  |    |_ src
  |         |_ main
  |              |_ aidl
  |              |_ assets
  |              |_ java
  |              |_ jniLibs
  |              |_ res
  |_ libraries
       |_ androidmedia_res
       |_ chrome_res
       |_ content_res
       |_ datausagechart_res
       |_ ui_res
</code></pre>

<p>注意事项：</p>

<ol>
<li>chromium项目的源码和资源有些是自动生成的，需要到out目录下去复制</li>
<li>pak和dat等文件需要加入到assets目录，而且不能压缩</li>
<li>aidl文件加入到main/aidl下，android studio会自动处理</li>
</ol>


<p>实践证明，这种方案是行之有效的，请参考github上的项目: <a href="https://github.com/mogoweb/365browser">365browser</a>。在script目录下有从chromium项目同步代码和资源的脚本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium for Android开源了]]></title>
    <link href="http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source/"/>
    <updated>2015-09-25T09:08:49+08:00</updated>
    <id>http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source</id>
    <content type="html"><![CDATA[<p>最近一段时间都在忙其它的事情，没有关注chromium的最新进展。这几天浏览 <a href="http://www.chromium.org">http://www.chromium.org</a> 上的文档，发现android build目标增加了一个：chrome_public_apk。编译方法：</p>

<blockquote><h1>Build the full browser</h1>

<p>~/chromium/src$ ninja -C out/Release chrome_public_apk</p>

<p>~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk</p></blockquote>

<p>搜索了一下相关新闻，大约在2015年5月份开始，chromium中开始加入了chrome for android的源码。从2012年开始，chromium中开始出现Android的移植代码，但只有Content API和ContentShell，离一个完备的浏览器还有一定的距离。当然，基于Content API开发浏览器也是可行的，当年就是这么干的。Chromium for Android和Chrome for Android并非完全一样，就如同桌面版Chromium浏览器和Chrome浏览器之间的区别。</p>

<p>下面放上一些Chromium for Android浏览器的截图，慢慢品味吧：</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_welcome.png" alt="welcome" /></p>

<p>欢迎界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_account.png" alt="account" /></p>

<p>帐号同步界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_main.png" alt="main" /></p>

<p>浏览器主界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_menu.png" alt="menu" /></p>

<p>浏览器菜单</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_settings.png" alt="settings" /></p>

<p>浏览器设置</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_tabs.png" alt="tabs" /></p>

<p>浏览器标签页</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打造自己的chrome for android]]></title>
    <link href="http://mogoweb.net/blog/2015/09/10/customize-chrome-for-android/"/>
    <updated>2015-09-10T22:01:54+08:00</updated>
    <id>http://mogoweb.net/blog/2015/09/10/customize-chrome-for-android</id>
    <content type="html"><![CDATA[<p>[注] 这是两年前写的一篇旧文，现翻出来，根据现在的实际变化作了修订。</p>

<p>chromium移植已经接近尾声，正在冲刺beta版本。不过越往后面，越是一些难啃的骨头。虽然背靠chromium这座大山，但是网页的复杂性超乎想象。更郁闷的是，有些BUG在chrome for android上没有，但在我们的浏览器上存在。因此经常会有这样的质疑：人家的chrome浏览器好好的，你做的浏览器为什么会有这样的问题。面对这样的质疑，真是有苦说不出。在有些人看来，别人都把源代码开放出来了，超过他们是理所当然的。没有办法，碰到难啃的骨头只能迎难而上了。好在chrome for android（V25之后的版本）开始支持自行定制了，虽然没法调试全部的代码，但是部分代码还是可以调试的。这样在分析我们和chrome浏览器在代码执行路径上的差异，也许能够提供一种思路。下面就谈谈如何构建自己的chrome for android。</p>

<!--excerpt-->


<ol>
<li><p>使用您的android设备下载chrome for android，如果能够翻墙的话就在Google Play下载，国内的应用商店也一般有，这里就不详细说了。</p></li>
<li><p>打开您的android设备上的chrome for android，地址栏中输入chrome://version</p></li>
<li><p>记下Build ID(版本号ID)后的那一长串数字。</p></li>
<li><p>在PC机上访问 <a href="http://storage.googleapis.com/chrome-browser-components/">http://storage.googleapis.com/chrome-browser-components/</a>&lt;BUILD_ID>/index.html。其中&lt;BUILD_ID>为步骤3中的ID。下载该页面所列的文件。以下将以$CHROME_PREBUILT指代所存放的目录。</p></li>
<li><p>下载与chrome for android版本对应的chromium源码，请参考[<a href="http://dev.chromium.org/developers/how-tos/get-the-code#TOC-Check-out-the-source-for-a-branch-or-specific-release">http://dev.chromium.org/developers/how-tos/get-the-code#TOC-Check-out-the-source-for-a-branch-or-specific-release</a>]上的指导将代码切换到正确的release分支。下面就以$CHROMIUM_SRC指代chromium源码的src目录</p></li>
<li><p>build出自己的libchromeview.so库</p>

<ul>
<li>cd $CHROMIUM_SRC</li>
<li>mkdir chrome-android-prebuilts</li>
<li>cp $CHROME_PREBUILT/chromeview_target.gyp chrome-android-prebuilts/libchrome.gyp</li>
<li>mkdir -p out/Release</li>
<li>cp $CHROME_PREBUILT/libchrome_android_prebuilt.a out/Release</li>
<li>CHROMIUM_GYP_FILE=&ldquo;chrome-android-prebuilts/libchrome.gyp&rdquo; build/gyp_chromium</li>
<li>ninja -C  out/Release libchrome_prebuilt</li>
</ul>
</li>
<li><p>解包官方chrome的apk</p>

<ul>
<li> 使用USB连接设备</li>
<li> cd $CHROME_SRC</li>
<li> mkdir out/apk</li>
<li> cd out/apk</li>
<li> adb pull $(adb shell pm path $CHROME_PACKAGE | sed &#8216;s/package:([^\r ]+).*$/\1/g&#8217;)</li>
<li> 将pull出的apk重命名为Chrome.apk</li>
<li> apktool d Chrome.apk</li>
</ul>


<p> 注1：您也可以从网上下载Chrome for android，但要确保下载正确的版本</p>

<p> 注2：apktool 可以从<a href="http://code.google.com/p/android-apktool/">http://code.google.com/p/android-apktool/</a> 下载</p></li>
<li><p>更新应用程序包</p>

<ul>
<li> cp $CHROME_PREBUILT/change_chromium_package.py .</li>
<li> chmod a+x change_chromium_package.py</li>
<li> ./change_chromium_package.py -u Chrome -p desired_package_name -a desired_app_name</li>
<li> cp $CHROMIUM_SRC/out/Release/lib.target/libchromeview_prebuilt.so libchromeview.so</li>
<li> arm-linux-androideabi-strip libchromeview.so</li>
<li> cp libchromeview.so $CHROMIUM_SRC/out/apk/Chrome/lib/armeabi-v7a</li>
</ul>
</li>
<li><p>重新打包和安装apk</p>

<ul>
<li> apktool b Chrome Chromium_unaligned.apk</li>
<li> 签名apk，为了简便起见，可以使用debug key：</li>
</ul>


<blockquote><p>jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore PATH_TO_ANDROID_SDK/.android/debug.keystore -storepass android Chromium_unaligned.apk androiddebugkey</p></blockquote>

<ul>
<li> zipalign -f -v 4 Chromium_unaligned.apk Chromium.apk</li>
<li> adb install -r Chromium.apk</li>
</ul>
</li>
</ol>


<p>到此，自有品牌的chrome浏览器就此诞生，您可以更换logo，修复chromium的bug等等。</p>
]]></content>
  </entry>
  
</feed>
