<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 放飞梦想]]></title>
  <link href="http://mogoweb.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://mogoweb.net/"/>
  <updated>2015-11-13T21:51:20+08:00</updated>
  <id>http://mogoweb.net/</id>
  <author>
    <name><![CDATA[mogoweb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android源码阅读与理解（一）：开篇]]></title>
    <link href="http://mogoweb.net/blog/2015/11/13/reading-android-source-preface/"/>
    <updated>2015-11-13T20:36:35+08:00</updated>
    <id>http://mogoweb.net/blog/2015/11/13/reading-android-source-preface</id>
    <content type="html"><![CDATA[<p>作为一个自认为苦逼的程序员，有一阵子曾考虑逃离程序世界，做一个文艺青年。你看，出去旅旅游、读读书、摄个影，没事发个呆，生活该是多么的惬意。反观程序员，每天对着冰冷的机器，有事无事还要加个班。正如一个段子所写：</p>

<blockquote><p>你苦战通宵游戏时，布里斯班的灯鱼已划过珊瑚丛;</p>

<p>你赶场招聘会时，蒙巴萨的小蟹刚溜出渔夫的掌心;</p>

<p>你写程序代码时，布拉格的电车正摇着铃晃过金色夕阳;</p>

<p>你挤进汹涌的食堂时，哥本哈根的街头画家完成了第99幅立体画。</p>

<p>有一些穿高跟鞋走不到的路，有一些喷着香水闻不到的空气，有一些在楼宇里永远碰遇不到的人。</p></blockquote>

<p>但是，看村上春书的《当我谈跑步时我谈些什么》如同嚼蜡，看侯孝贤、王家卫的电影直睡觉之后，我发现其实身上缺少文艺细胞，无事发呆更是让我难受。其实仔细想想，写代码时虽然苦逼，但是当纠出一个苦苦追寻了半个月的bug的时刻，内心还是感觉很爽的。不读村上春树，读读东野圭吾也挺开心的。每天充实的感觉比无所事事更舒服。所以，我还是需要做回自己，做自己喜欢、自己擅长的事情。读到池建强的《是旅行还是长跑》中这样一段话：</p>

<blockquote><p>只要你没有一个强悍的爹，就要先忘掉那些小鱼小蟹，还有珊瑚丛，那些暂时还不属于你，踏踏实实地练习和提升才是王道，为自己规划一个十年的长跑，可以时不时停下来休息一下，低下头汗水就落入尘埃，抬起头就看看夕阳西下，你抹去疲惫，然后继续前行。十年看似很长，但实在很短，十年以后你回头看看，你究竟是成了人中龙凤，还是小鱼小虾，是你认知了世界，还是世界抛弃了你。</p></blockquote>

<p>瞬间引起了共鸣。</p>

<p>闲话扯远了，作为一个国产OS的从业者，一直都从Android系统吸(chao)收(xi)营(yuan)养(ma)。其实我们更想借鉴ios系统，可惜人家不开源，光看表面是做不了神似的。在开发的过程中，也碰到不少问题，零零碎碎读过一些Android的源码，但基本上都是现学现用，缺乏整体的理解。既然做不了文艺青年，那我就来挑战一下Android系统源码吧。当然现在Android源码分析的书和文章也比较多，比如我手头就有邓凡平的《深入理解Android》、杨云君的《Android的设计与实现》和罗升阳的《Android系统源代码情景分析》，网上的文章更是不计其数。但别人分析了也是别人的，买了他们的书，但买不到他们的知识。还是需要亲自深入代码分析，知识才能变成我的。</p>

<p>在后续的学习中，我将结合自身的工作，分析我所感兴趣的部分。Android系统是一个相当庞大的系统，想要深入掌握每个细节，那是一个不可能完成的任务。所以我会略去驱动、linux内核、media等部分，初步计划阅读的部分如下：</p>

<ol>
<li>Android build系统</li>
<li>Android系统启动</li>
<li>Binder原理与实现</li>
<li>Surface系统</li>
<li>Dalvik虚拟机</li>
<li>chromium Webview</li>
</ol>


<p>为了让自己能坚持下去，要求在阅读过程中记笔记，每周至少写一篇博客，梳理一下阅读心得。希望我能够坚持下去并有所得，加油！</p>

<p><strong>[注]</strong> 本文引用的文字出自池建强《MacTalk人生元编程》P.194。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于chromium for android开发Android浏览器]]></title>
    <link href="http://mogoweb.net/blog/2015/11/03/develop-android-browser-base-on-chromium-for-android/"/>
    <updated>2015-11-03T08:39:21+08:00</updated>
    <id>http://mogoweb.net/blog/2015/11/03/develop-android-browser-base-on-chromium-for-android</id>
    <content type="html"><![CDATA[<p>在上一篇文章&lt;&lt; <a href="http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source/">Chromium for Android开源了</a> >>中谈到了Google已经完全开源了Chromium for Android，这样我们就完全可以开发与Chrome for Android媲美的Android浏览器了。通常浏览器的一些新特性和新功能会先出现在Chromium for Android上，稳定后才会出现在Chrome for Android上，如果我们基于Chromium for Android开发浏览器产品，在新特性和新功能方面不会落后于Chrome浏览器.</p>

<p>Chromium开源项目的代码及其庞大，也相当的复杂。对于Android开发人员，特别是UI开发人员来说，没有一个合适的IDE环境，会是一个非常痛苦的事情。我们通常是这样开发的，在sublime text中阅读、修改代码，使用chromium的构建系统build出apk，安装到手机，进行调试。对于native代码来说，这样的开发方式也不会有太多麻烦，因为native部分的代码通常修改很少。但如果主要进行UI的定制，这种开发方式就非常痛苦了。</p>

<p>为了应对这个问题，考虑如下方案：</p>

<ol>
<li>采用Android Studio作为开发环境，从Chromium for Android抽取chrome模块的源码，加入Android project。</li>
<li>native代码在chromium环境中build，作为so加入Android project</li>
<li>基础模块(base, content, net等)在chromium环境build为jar包，加入Android project</li>
<li>content, chrome, ui等模块的资源文件加入Android library project</li>
</ol>


<p>资源文件为什么不能直接都添加到Android project呢？因为命名空间的原因，比如content模块的资源的命名空间为org.chromium.content, chrome模块的资源的命名空间为org.chromium.chrome，所以需要建立不同的Android library project, 指定不同的包名。最后整个项目的结构如下：</p>

<pre><code>browser
  |_ app
  |    |_ libs
  |    |_ src
  |         |_ main
  |              |_ aidl
  |              |_ assets
  |              |_ java
  |              |_ jniLibs
  |              |_ res
  |_ libraries
       |_ androidmedia_res
       |_ chrome_res
       |_ content_res
       |_ datausagechart_res
       |_ ui_res
</code></pre>

<p>注意事项：</p>

<ol>
<li>chromium项目的源码和资源有些是自动生成的，需要到out目录下去复制</li>
<li>pak和dat等文件需要加入到assets目录，而且不能压缩</li>
<li>aidl文件加入到main/aidl下，android studio会自动处理</li>
</ol>


<p>实践证明，这种方案是行之有效的，请参考github上的项目: <a href="https://github.com/mogoweb/365browser">365browser</a>。在script目录下有从chromium项目同步代码和资源的脚本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium for Android开源了]]></title>
    <link href="http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source/"/>
    <updated>2015-09-25T09:08:49+08:00</updated>
    <id>http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source</id>
    <content type="html"><![CDATA[<p>最近一段时间都在忙其它的事情，没有关注chromium的最新进展。这几天浏览 <a href="http://www.chromium.org">http://www.chromium.org</a> 上的文档，发现android build目标增加了一个：chrome_public_apk。编译方法：</p>

<blockquote><h1>Build the full browser</h1>

<p>~/chromium/src$ ninja -C out/Release chrome_public_apk</p>

<p>~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk</p></blockquote>

<p>搜索了一下相关新闻，大约在2015年5月份开始，chromium中开始加入了chrome for android的源码。从2012年开始，chromium中开始出现Android的移植代码，但只有Content API和ContentShell，离一个完备的浏览器还有一定的距离。当然，基于Content API开发浏览器也是可行的，当年就是这么干的。Chromium for Android和Chrome for Android并非完全一样，就如同桌面版Chromium浏览器和Chrome浏览器之间的区别。</p>

<p>下面放上一些Chromium for Android浏览器的截图，慢慢品味吧：</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_welcome.png" alt="welcome" /></p>

<p>欢迎界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_account.png" alt="account" /></p>

<p>帐号同步界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_main.png" alt="main" /></p>

<p>浏览器主界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_menu.png" alt="menu" /></p>

<p>浏览器菜单</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_settings.png" alt="settings" /></p>

<p>浏览器设置</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_tabs.png" alt="tabs" /></p>

<p>浏览器标签页</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打造自己的chrome for android]]></title>
    <link href="http://mogoweb.net/blog/2015/09/10/customize-chrome-for-android/"/>
    <updated>2015-09-10T22:01:54+08:00</updated>
    <id>http://mogoweb.net/blog/2015/09/10/customize-chrome-for-android</id>
    <content type="html"><![CDATA[<p>[注] 这是两年前写的一篇旧文，现翻出来，根据现在的实际变化作了修订。</p>

<p>chromium移植已经接近尾声，正在冲刺beta版本。不过越往后面，越是一些难啃的骨头。虽然背靠chromium这座大山，但是网页的复杂性超乎想象。更郁闷的是，有些BUG在chrome for android上没有，但在我们的浏览器上存在。因此经常会有这样的质疑：人家的chrome浏览器好好的，你做的浏览器为什么会有这样的问题。面对这样的质疑，真是有苦说不出。在有些人看来，别人都把源代码开放出来了，超过他们是理所当然的。没有办法，碰到难啃的骨头只能迎难而上了。好在chrome for android（V25之后的版本）开始支持自行定制了，虽然没法调试全部的代码，但是部分代码还是可以调试的。这样在分析我们和chrome浏览器在代码执行路径上的差异，也许能够提供一种思路。下面就谈谈如何构建自己的chrome for android。</p>

<!--excerpt-->


<ol>
<li><p>使用您的android设备下载chrome for android，如果能够翻墙的话就在Google Play下载，国内的应用商店也一般有，这里就不详细说了。</p></li>
<li><p>打开您的android设备上的chrome for android，地址栏中输入chrome://version</p></li>
<li><p>记下Build ID(版本号ID)后的那一长串数字。</p></li>
<li><p>在PC机上访问 <a href="http://storage.googleapis.com/chrome-browser-components/">http://storage.googleapis.com/chrome-browser-components/</a>&lt;BUILD_ID>/index.html。其中&lt;BUILD_ID>为步骤3中的ID。下载该页面所列的文件。以下将以$CHROME_PREBUILT指代所存放的目录。</p></li>
<li><p>下载与chrome for android版本对应的chromium源码，请参考[<a href="http://dev.chromium.org/developers/how-tos/get-the-code#TOC-Check-out-the-source-for-a-branch-or-specific-release">http://dev.chromium.org/developers/how-tos/get-the-code#TOC-Check-out-the-source-for-a-branch-or-specific-release</a>]上的指导将代码切换到正确的release分支。下面就以$CHROMIUM_SRC指代chromium源码的src目录</p></li>
<li><p>build出自己的libchromeview.so库</p>

<ul>
<li>cd $CHROMIUM_SRC</li>
<li>mkdir chrome-android-prebuilts</li>
<li>cp $CHROME_PREBUILT/chromeview_target.gyp chrome-android-prebuilts/libchrome.gyp</li>
<li>mkdir -p out/Release</li>
<li>cp $CHROME_PREBUILT/libchrome_android_prebuilt.a out/Release</li>
<li>CHROMIUM_GYP_FILE=&ldquo;chrome-android-prebuilts/libchrome.gyp&rdquo; build/gyp_chromium</li>
<li>ninja -C  out/Release libchrome_prebuilt</li>
</ul>
</li>
<li><p>解包官方chrome的apk</p>

<ul>
<li> 使用USB连接设备</li>
<li> cd $CHROME_SRC</li>
<li> mkdir out/apk</li>
<li> cd out/apk</li>
<li> adb pull $(adb shell pm path $CHROME_PACKAGE | sed &#8216;s/package:([^\r ]+).*$/\1/g&#8217;)</li>
<li> 将pull出的apk重命名为Chrome.apk</li>
<li> apktool d Chrome.apk</li>
</ul>


<p> 注1：您也可以从网上下载Chrome for android，但要确保下载正确的版本</p>

<p> 注2：apktool 可以从<a href="http://code.google.com/p/android-apktool/">http://code.google.com/p/android-apktool/</a> 下载</p></li>
<li><p>更新应用程序包</p>

<ul>
<li> cp $CHROME_PREBUILT/change_chromium_package.py .</li>
<li> chmod a+x change_chromium_package.py</li>
<li> ./change_chromium_package.py -u Chrome -p desired_package_name -a desired_app_name</li>
<li> cp $CHROMIUM_SRC/out/Release/lib.target/libchromeview_prebuilt.so libchromeview.so</li>
<li> arm-linux-androideabi-strip libchromeview.so</li>
<li> cp libchromeview.so $CHROMIUM_SRC/out/apk/Chrome/lib/armeabi-v7a</li>
</ul>
</li>
<li><p>重新打包和安装apk</p>

<ul>
<li> apktool b Chrome Chromium_unaligned.apk</li>
<li> 签名apk，为了简便起见，可以使用debug key：</li>
</ul>


<blockquote><p>jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore PATH_TO_ANDROID_SDK/.android/debug.keystore -storepass android Chromium_unaligned.apk androiddebugkey</p></blockquote>

<ul>
<li> zipalign -f -v 4 Chromium_unaligned.apk Chromium.apk</li>
<li> adb install -r Chromium.apk</li>
</ul>
</li>
</ol>


<p>到此，自有品牌的chrome浏览器就此诞生，您可以更换logo，修复chromium的bug等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Chromium for Android中能否用TextureView替代SurfaceView]]></title>
    <link href="http://mogoweb.net/blog/2015/06/19/using-textureview-instead-of-surfaceview-in-chrome-for-android/"/>
    <updated>2015-06-19T19:26:45+08:00</updated>
    <id>http://mogoweb.net/blog/2015/06/19/using-textureview-instead-of-surfaceview-in-chrome-for-android</id>
    <content type="html"><![CDATA[<p>在开发Browser 2.0时，碰到一个非常头疼的问题，往布局上添加SurfaceView时，会引起黑屏闪一下。为了解决这个问题，我们不得不在初始化阶段就把SurfaceView添加好，之后也不能调整大小、移动位置。当时就考虑是不是能够用TextureView替代SurfaceView，不过由于计划上的调整，没有做进一步的尝试。今天在网上看到<a href="https://github.com/crosswalk-project/crosswalk-website/wiki/Android-SurfaceView-vs-TextureView">这篇文章</a>，正好解答了我的疑问，在此把文章翻译过来，供参考。</p>

<blockquote><h1>Android SurfaceView和textureView</h1>

<p>本文将简要介绍SurfaceView和TextureView的不同之处</p>

<h2>SurfaceView和TextureView</h2>

<p>SurfaceView和TextureView都继承自android.view.View类，他们都可以在另一个独立线程中绘制和渲染，这是和其它View的最大不同。Crosswalk采用这一分离绘制特性，独立的GPU线程显著提高了渲染效率。</p>

<p>SurfaceView提供一个嵌入在视图层次上的专用绘制表面，您可以控制该表面（Surface）的格式和尺寸。SurfaceView负责将表面放置在屏幕上正确的位置。它的行为多少有些类似于传统桌面系统上的onscreen窗口，比如，X11系统中的XWindow可以是无边框的，嵌入在另一个XWindow中。</p>

<p>SurfaceView存在如下两个缺点：</p>

<ul>
<li>不能应用动画、变换和缩放</li>
<li>不能叠加（Overlay）两个SurfaceView</li>
</ul>


<p>TextureView看似更像一个通用的View，可以应用动画、变换和缩放，就如同TextView。TextureView只能用在硬件加速的窗口。但是，TextureView比SurfaceView更耗内存，而且可能会有1～3帧的延迟，请参考讨论<a href="https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4">3</a>。</p>

<h2>使用可以动画的XWalkView</h2>

<p>Crosswalk Embedding API for Android很好的支持了SurfaceView和TextureView。XWalkView缺省使用SurfaceView，也允许您在以下情况下使用TextureView：</p>

<ul>
<li>您想让XWalkView支持动画和变换</li>
<li>您想叠加两个XWalkView</li>
</ul>


<p>设置布尔标识ANIMATIBLE_XWALK_VIEW为true即可启用TextureView。</p>

<ol>
<li><a href="http://developer.android.com/reference/android/view/SurfaceView.html">http://developer.android.com/reference/android/view/SurfaceView.html</a></li>
<li><a href="http://developer.android.com/reference/android/view/TextureView.html">http://developer.android.com/reference/android/view/TextureView.html</a></li>
<li><a href="https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4">https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4</a></li>
</ol>
</blockquote>

<p>文中提到的讨论起源是在google groups中有人提出如下问题：</p>

<blockquote><p>在当前ContentViewRenderView实现中，使用SurfaceView作为合成表面(compositing surface)，如我们所知，SurfaceView是一个特别的视图，无法进行动画或者变换。</p>

<p>TextureView可以做SufaceView同样的事情，比如，您可以在另一个独立线程中渲染，也可以从底下的SurfaceTexture创建一个egl表面(eglSurface)。更主要的是，TextureView可以进行动画和变换。</p>

<p>我很好奇为什么不使用TextureView作为合成表面，是否TextureView在使用上有一些特别的考虑，比如性能问题？欢迎任何讨论。</p></blockquote>

<p>Google groups有人做如下回复：</p>

<blockquote><p>事实上chrome过去使用TextureView作为合成表面，但我们出于几个原因切换到SurfaceView：</p>

<ul>
<li>由于失效(invalidation)和缓冲的特性，TextureView增加了额外1~3帧的延迟显示画面更新</li>
<li>TextureView总是使用GL合成，而SurfaceTexture可以使用硬件overlay后端，可以占用更少的内存带宽，消耗更少的能量</li>
<li>TextureView的内部缓冲队列导致比SurfaceView使用更多的内存</li>
<li>TextureView的动画和变换能力我们用不上</li>
</ul>
</blockquote>

<p>所以结论是Chromium for Android中可以使用TextureView替代SurfaceView作为合成表面，但带来的后果是占用更多的内存，性能下降。</p>
]]></content>
  </entry>
  
</feed>
