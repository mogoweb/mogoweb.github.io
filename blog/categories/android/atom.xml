<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 放飞梦想]]></title>
  <link href="http://mogoweb.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://mogoweb.github.io/"/>
  <updated>2015-09-24T16:03:13+08:00</updated>
  <id>http://mogoweb.github.io/</id>
  <author>
    <name><![CDATA[mogoweb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[打造自己的chrome for android]]></title>
    <link href="http://mogoweb.github.io/blog/2015/09/10/customize-chrome-for-android/"/>
    <updated>2015-09-10T22:01:54+08:00</updated>
    <id>http://mogoweb.github.io/blog/2015/09/10/customize-chrome-for-android</id>
    <content type="html"><![CDATA[<p>[注] 这是两年前写的一篇旧文，现翻出来，根据现在的实际变化作了修订。</p>

<p>chromium移植已经接近尾声，正在冲刺beta版本。不过越往后面，越是一些难啃的骨头。虽然背靠chromium这座大山，但是网页的复杂性超乎想象。更郁闷的是，有些BUG在chrome for android上没有，但在我们的浏览器上存在。因此经常会有这样的质疑：人家的chrome浏览器好好的，你做的浏览器为什么会有这样的问题。面对这样的质疑，真是有苦说不出。在有些人看来，别人都把源代码开放出来了，超过他们是理所当然的。没有办法，碰到难啃的骨头只能迎难而上了。好在chrome for android（V25之后的版本）开始支持自行定制了，虽然没法调试全部的代码，但是部分代码还是可以调试的。这样在分析我们和chrome浏览器在代码执行路径上的差异，也许能够提供一种思路。下面就谈谈如何构建自己的chrome for android。</p>

<!--excerpt-->


<ol>
<li><p>使用您的android设备下载chrome for android，如果能够翻墙的话就在Google Play下载，国内的应用商店也一般有，这里就不详细说了。</p></li>
<li><p>打开您的android设备上的chrome for android，地址栏中输入chrome://version</p></li>
<li><p>记下Build ID(版本号ID)后的那一长串数字。</p></li>
<li><p>在PC机上访问 <a href="http://storage.googleapis.com/chrome-browser-components/">http://storage.googleapis.com/chrome-browser-components/</a>&lt;BUILD_ID>/index.html。其中&lt;BUILD_ID>为步骤3中的ID。下载该页面所列的文件。以下将以$CHROME_PREBUILT指代所存放的目录。</p></li>
<li><p>下载与chrome for android版本对应的chromium源码，请参考[<a href="http://dev.chromium.org/developers/how-tos/get-the-code#TOC-Check-out-the-source-for-a-branch-or-specific-release">http://dev.chromium.org/developers/how-tos/get-the-code#TOC-Check-out-the-source-for-a-branch-or-specific-release</a>]上的指导将代码切换到正确的release分支。下面就以$CHROMIUM_SRC指代chromium源码的src目录</p></li>
<li><p>build出自己的libchromeview.so库</p>

<ul>
<li>cd $CHROMIUM_SRC</li>
<li>mkdir chrome-android-prebuilts</li>
<li>cp $CHROME_PREBUILT/chromeview_target.gyp chrome-android-prebuilts/libchrome.gyp</li>
<li>mkdir -p out/Release</li>
<li>cp $CHROME_PREBUILT/libchrome_android_prebuilt.a out/Release</li>
<li>CHROMIUM_GYP_FILE=&ldquo;chrome-android-prebuilts/libchrome.gyp&rdquo; build/gyp_chromium</li>
<li>ninja -C  out/Release libchrome_prebuilt</li>
</ul>
</li>
<li><p>解包官方chrome的apk</p>

<ul>
<li> 使用USB连接设备</li>
<li> cd $CHROME_SRC</li>
<li> mkdir out/apk</li>
<li> cd out/apk</li>
<li> adb pull $(adb shell pm path $CHROME_PACKAGE | sed &#8216;s/package:([^\r ]+).*$/\1/g&#8217;)</li>
<li> 将pull出的apk重命名为Chrome.apk</li>
<li> apktool d Chrome.apk</li>
</ul>


<p> 注1：您也可以从网上下载Chrome for android，但要确保下载正确的版本</p>

<p> 注2：apktool 可以从<a href="http://code.google.com/p/android-apktool/">http://code.google.com/p/android-apktool/</a> 下载</p></li>
<li><p>更新应用程序包</p>

<ul>
<li> cp $CHROME_PREBUILT/change_chromium_package.py .</li>
<li> chmod a+x change_chromium_package.py</li>
<li> ./change_chromium_package.py -u Chrome -p desired_package_name -a desired_app_name</li>
<li> cp $CHROMIUM_SRC/out/Release/lib.target/libchromeview_prebuilt.so libchromeview.so</li>
<li> arm-linux-androideabi-strip libchromeview.so</li>
<li> cp libchromeview.so $CHROMIUM_SRC/out/apk/Chrome/lib/armeabi-v7a</li>
</ul>
</li>
<li><p>重新打包和安装apk</p>

<ul>
<li> apktool b Chrome Chromium_unaligned.apk</li>
<li> 签名apk，为了简便起见，可以使用debug key：</li>
</ul>


<blockquote><p>jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore PATH_TO_ANDROID_SDK/.android/debug.keystore -storepass android Chromium_unaligned.apk androiddebugkey</p></blockquote>

<ul>
<li> zipalign -f -v 4 Chromium_unaligned.apk Chromium.apk</li>
<li> adb install -r Chromium.apk</li>
</ul>
</li>
</ol>


<p>到此，自有品牌的chrome浏览器就此诞生，您可以更换logo，修复chromium的bug等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Chromium for Android中能否用TextureView替代SurfaceView]]></title>
    <link href="http://mogoweb.github.io/blog/2015/06/19/using-textureview-instead-of-surfaceview-in-chrome-for-android/"/>
    <updated>2015-06-19T19:26:45+08:00</updated>
    <id>http://mogoweb.github.io/blog/2015/06/19/using-textureview-instead-of-surfaceview-in-chrome-for-android</id>
    <content type="html"><![CDATA[<p>在开发Browser 2.0时，碰到一个非常头疼的问题，往布局上添加SurfaceView时，会引起黑屏闪一下。为了解决这个问题，我们不得不在初始化阶段就把SurfaceView添加好，之后也不能调整大小、移动位置。当时就考虑是不是能够用TextureView替代SurfaceView，不过由于计划上的调整，没有做进一步的尝试。今天在网上看到<a href="https://github.com/crosswalk-project/crosswalk-website/wiki/Android-SurfaceView-vs-TextureView">这篇文章</a>，正好解答了我的疑问，在此把文章翻译过来，供参考。</p>

<blockquote><h1>Android SurfaceView和textureView</h1>

<p>本文将简要介绍SurfaceView和TextureView的不同之处</p>

<h2>SurfaceView和TextureView</h2>

<p>SurfaceView和TextureView都继承自android.view.View类，他们都可以在另一个独立线程中绘制和渲染，这是和其它View的最大不同。Crosswalk采用这一分离绘制特性，独立的GPU线程显著提高了渲染效率。</p>

<p>SurfaceView提供一个嵌入在视图层次上的专用绘制表面，您可以控制该表面（Surface）的格式和尺寸。SurfaceView负责将表面放置在屏幕上正确的位置。它的行为多少有些类似于传统桌面系统上的onscreen窗口，比如，X11系统中的XWindow可以是无边框的，嵌入在另一个XWindow中。</p>

<p>SurfaceView存在如下两个缺点：</p>

<ul>
<li>不能应用动画、变换和缩放</li>
<li>不能叠加（Overlay）两个SurfaceView</li>
</ul>


<p>TextureView看似更像一个通用的View，可以应用动画、变换和缩放，就如同TextView。TextureView只能用在硬件加速的窗口。但是，TextureView比SurfaceView更耗内存，而且可能会有1～3帧的延迟，请参考讨论<a href="https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4">3</a>。</p>

<h2>使用可以动画的XWalkView</h2>

<p>Crosswalk Embedding API for Android很好的支持了SurfaceView和TextureView。XWalkView缺省使用SurfaceView，也允许您在以下情况下使用TextureView：</p>

<ul>
<li>您想让XWalkView支持动画和变换</li>
<li>您想叠加两个XWalkView</li>
</ul>


<p>设置布尔标识ANIMATIBLE_XWALK_VIEW为true即可启用TextureView。</p>

<ol>
<li><a href="http://developer.android.com/reference/android/view/SurfaceView.html">http://developer.android.com/reference/android/view/SurfaceView.html</a></li>
<li><a href="http://developer.android.com/reference/android/view/TextureView.html">http://developer.android.com/reference/android/view/TextureView.html</a></li>
<li><a href="https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4">https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4</a></li>
</ol>
</blockquote>

<p>文中提到的讨论起源是在google groups中有人提出如下问题：</p>

<blockquote><p>在当前ContentViewRenderView实现中，使用SurfaceView作为合成表面(compositing surface)，如我们所知，SurfaceView是一个特别的视图，无法进行动画或者变换。</p>

<p>TextureView可以做SufaceView同样的事情，比如，您可以在另一个独立线程中渲染，也可以从底下的SurfaceTexture创建一个egl表面(eglSurface)。更主要的是，TextureView可以进行动画和变换。</p>

<p>我很好奇为什么不使用TextureView作为合成表面，是否TextureView在使用上有一些特别的考虑，比如性能问题？欢迎任何讨论。</p></blockquote>

<p>Google groups有人做如下回复：</p>

<blockquote><p>事实上chrome过去使用TextureView作为合成表面，但我们出于几个原因切换到SurfaceView：</p>

<ul>
<li>由于失效(invalidation)和缓冲的特性，TextureView增加了额外1~3帧的延迟显示画面更新</li>
<li>TextureView总是使用GL合成，而SurfaceTexture可以使用硬件overlay后端，可以占用更少的内存带宽，消耗更少的能量</li>
<li>TextureView的内部缓冲队列导致比SurfaceView使用更多的内存</li>
<li>TextureView的动画和变换能力我们用不上</li>
</ul>
</blockquote>

<p>所以结论是Chromium for Android中可以使用TextureView替代SurfaceView作为合成表面，但带来的后果是占用更多的内存，性能下降。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Chromium WebView项目的源代码管理]]></title>
    <link href="http://mogoweb.github.io/blog/2014/06/19/about-source-management-of-chromium-webview/"/>
    <updated>2014-06-19T10:53:25+08:00</updated>
    <id>http://mogoweb.github.io/blog/2014/06/19/about-source-management-of-chromium-webview</id>
    <content type="html"><![CDATA[<p>chromium项目可谓开源项目集大成者，里面使用的第三方开源库数目高达60+。为了应对庞大的代码库管理问题，chromium项目引入了<a href="http://code.google.com/p/gclient/">gclient</a>，一套开源的代码管理方案。gclient是一套python脚本，用来简化多个git/svn源码库的管理。本文不探讨gclient的使用、配置，而是谈谈chromium webview项目是如何组织源码库的。</p>

<p>由于历史原因，chromium项目本身及许多第三方开源库采用的是SVN源码管理系统。SVN采用的是集中式管理，不如git那样能否方便的clone代码库。虽然google后来使用了git-svn等手段，为chromium和所有第三方开源库都做了git镜像库，但是如果需要获取某个release分支的代码，还是需要走svn（google也在不断改进，期望不久的将来，可以通过git获取某个release版本的源码）。</p>

<!--more-->


<p>基于chromium的开源项目有三种组织源码方案：</p>

<ol>
<li><a href="http://code.google.com/p/chromiumembedded">CEF</a>开源项目本身没有放chromium源码，只是提供了一套脚本，从google的服务器上去获取对应的源码，对chromium所做的修改以patch提交，同样提供了脚本应用这些patch。有了自动化脚本，开发人员其实也不关心代码托管在何处，项目组也可以省掉同步chromium源码的工作。但这种方案对项目组人员要求较高，必须要有扎实的脚本语言开发功底，每次对chromium的修改都必须做patch，也很考研开发人员的细致与耐心程度。</li>
<li><a href="https://www.codeaurora.org/xwiki/bin/Chromium+for+Snapdragon/WebHome">Chromium Browser for Snapdragon Project</a>开源项目为所有chromium及第三方开源库都做了git镜像，对chromium的修改直接提交到这些镜像库上。这种方案的优点是可控，非常适合企业内部开发，在企业内部部署，开发人员就无需每人都从外部下载，涉及到技术保密的提交也无需让外界知晓。但这种方案的缺点也是非常明显的，为60+个git库做镜像，有一定的工作量，还要定期同步，需要处理内部提交与外部提交合并问题。</li>
<li><a href="https://crosswalk-project.org/">crosswalk</a>开源项目只镜像了chromium/blink/v8等少量几个会修改的开源库，其它的库则从google的网站上取。这种方案在维护与便捷之间做了最佳平衡，因为chromium项目使用了大量的第三方开源库，但我们极少有需要去修改这些第三方开源库，处于定制和优化的目的，我们通常也只在chromium/blink库上修改代码。</li>
</ol>


<p>Chromium WebView项目采用了第三种方案，由于chromium和blink这两个库太庞大，屡次上传到github都失败，于是改成从crosswalk项目clone相关的代码库。所以在我的名下多了chromium-crosswalk, blink-crosswalk, v8-crosswalk这几个库，其实它们都是为chromium webview项目服务的，里面包含了crosswalk项目的代码，可以忽略之。</p>

<p>[注: 由于一些原因，在国内访问chromium的源码库不再顺畅了，免费的翻墙服务GAE也被屏蔽了，所以要同步代码，还需要购买商业的VPN，以保证网络是通畅的。您也可以从Chromium Browser for Snapdragon Project获取相关的git库，只要版本取的正确，可以同样使用。]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于chromium_webview项目]]></title>
    <link href="http://mogoweb.github.io/blog/2014/06/10/about-chromium-webview-project/"/>
    <updated>2014-06-10T08:56:06+08:00</updated>
    <id>http://mogoweb.github.io/blog/2014/06/10/about-chromium-webview-project</id>
    <content type="html"><![CDATA[<p>chromium_webview的目标是在chromium核心的基础上提供Android WebView API全兼容的接口，希望达到的效果是基于Android WebView API开发的应用程序，只需将android.webkit包名替换为com.mogoweb.chrome即可完成从WebKit内核到Chromium内核的迁移。目标支持平台为Android 4.0以上。项目地址：<a href="https://github.com/mogoweb/chromium_webview">https://github.com/mogoweb/chromium_webview</a>。</p>

<h2>项目的起源</h2>

<p>从2011年开始，我转向从事chromium的定制化工作。2012年在移动手机平台上开发了一款浏览器Browser1.0，基于WebKit内核和Android WebView API。2012年下半年开始进行chromium的移植工作，其时google发布了Chrome for Android的第一个版本V0.16，还是beta版本。虽然浏览器的内核发生了很大的变化，但是我们期望上层的代码不需要做修改，于是在Content API的基础上，按照Android WebView API进行接口封装。最后做出来的浏览器美其名曰“双内核”，也就是WebKit加Chromium双内核。</p>

<!--more-->


<p>由于Chromium渲染架构的缘故，在Content API之上封装的WebView API还存在问题：</p>

<ol>
<li>为了启用硬件加速，chromium for android引入了SurfaceView，但SurfaceView动态添加会引起黑屏。所以SurfaceView必须在应用程序的初始化代码中添加，不能象Android WebView那样随心所欲的使用。</li>
<li>采用了多进程架构，后果之一就是内存狂飙，更让人难以接受的是，访问新浪首页这样复杂的网页，还不如WebKit浏览器流畅。</li>
</ol>


<p>在我们移植chromium的同时，google的工程师也没闲着，chromium代码下面开始出现android_webview的代码，接着代码越来越多，更新的也越来越频繁。有一天，在github上看到一个项目：<a href="https://github.com/pwnall/chromeview">ChromeView Project</a>。这正是我所需要的基于chromium的WebView API封装,但这哥们估计也没啥闲功夫，项目好久都没有更新。于是我就在github上创建了chromium_webview项目，早期的AwContents实现是软件渲染，所以效率低下。</p>

<p>时间推到2013年11月，Android 4.4发布，其中很大的一个变化就是使用chromium替换了原来的webkit引擎。于是我又开始哼哧哼哧研究起AOSP中的Chromium WebView实现，研究了AOSP中的Chromium WebView实现后，定下了如下策略：</p>

<ol>
<li>照搬WebViewChromium及相关代码，如果代码中使用了未公开的API，使用反射机制实现。</li>
<li>启用光栅化位图，消除对GraphicBuffer的依赖，从而不依赖系统的未公开C++接口。</li>
</ol>


<p>经过一段时间的工作，chromium webview项目终于完整支持硬件加速。</p>

<h2>Chromium WebView的应用场景</h2>

<p>有人要说了，现在Android系统都已经采用chromium引擎了，你还费老大劲整出这玩意儿，是不是吃饱了撑了。的确，做这个事情没给我带来一毛钱经济上的收益，反而搭进了我的业余休息时间，我做这件事的动力来自：</p>

<ol>
<li>Android WebView采用chromium引擎不假，但那也得4.4及以上的版本。</li>
<li>使用系统的WebView，失去了定制能力，比如要添加一个HTML标签就比较难。</li>
<li>提高水平，结交朋友。</li>
</ol>


<p>早些年做《无线城市》项目时，就发现Hybrid App还是有一些市场的。但使用系统的WebView可能存在性能低下、兼容性不良、无法定制的问题。所以chromium webview的最佳应用场景就是集成到APP作为渲染引擎，此外开发浏览器也是一个选择。</p>

<h2>Chromium WebView存在的问题</h2>

<p>Chromium WebView刚完成了初步的移植，问题还非常多，在后续的时间，将会继续完善。目前看来，仍然有几大难题难以解决：</p>

<ol>
<li>由于渲染架构的原因，在Android 4.0 &amp; Android 4.0.3上还只能使用软件方式渲染；</li>
<li>光栅化位图的效率似乎比GraphicBuffer的效率低一些，长网页或复杂网页在快速滚动时，会出现短暂的白屏。</li>
</ol>


<h2>后续计划</h2>

<ol>
<li>完善Chromium WebView API，修复BUG</li>
<li>开启WebGL支持</li>
<li>精简内核，优化内存占用</li>
<li>将开源浏览器TintBrowser改成使用Chromium WebView，证明基于WebView API的应用能够无缝迁移到Chromium WebView。</li>
</ol>


<h2>更新</h2>

<p>2014-08-18</p>

<p>完成TintBrowser在Chromium WebView上的适配，并修改了若干UI，命名为365浏览器，已经在腾讯开放平台上上架，你可以从<a href="http://android.myapp.com/myapp/detail.htm?apkName=com.mogoweb">这里</a>下载。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium网络加载速度研究(2)]]></title>
    <link href="http://mogoweb.github.io/blog/2014/04/03/chromium-loading-spped-research-1/"/>
    <updated>2014-04-03T18:10:06+08:00</updated>
    <id>http://mogoweb.github.io/blog/2014/04/03/chromium-loading-spped-research-1</id>
    <content type="html"><![CDATA[<p>本文主要内容翻译自chromium的文档<a href="http://www.chromium.org/developers/design-documents/network-stack/netlog">NetLog: Chrome’s network logging system</a>，如果您觉得文章写的不明白，请参看原文。</p>

<p>通过&lt;&lt;<a href="http://mogoweb.github.io/blog/2014/03/18/chromium-loading-speed-research-0/">Chromium网络加载速度研究(1)</a>>>这篇文章的分析，可以得出结论，云端加速是高富帅的玩法。对于个人开发者和小公司而言，是没有那个实力去部署强大的数据中心的。所以接下来还得继续研究，看看有没有其它的途径提高网页加载速度。在着手优化之前，我们需要一个profiling手段找出瓶颈，有目的的优化。另一方面，也需要考虑如何评估优化的效果。如果没有一个客观的评估，优化方案是否有效心中就没有底。谈到Profiling，大多数人估计都会想到log大法，就是在程序的一些关键位置打上log。log通常包括时间、事件、状态等。在chromium中，开发人员早就预料了此类需求，设计了一套强大的NetLog。下面就分析一下chromium中NetLog的设计、实现及其用法。</p>

<!--more-->


<h2>概述</h2>

<p>NetLog是一套为Chrome网络栈而设计的事件日志机制，帮助调试问题和分析性能。它遵照&#8221;抓取->转储->分析&#8221;的工作流程，这点和某些工具，如tcpdump有些相像。</p>

<p>典型的使用场景为：</p>

<ol>
<li>用户启用网络日志</li>
<li>用户重现问题</li>
<li>用户将日志上传到BUG报告系统</li>
<li>开发人员分析日志，定位问题</li>
</ol>


<p>在chrome网络栈内部，在一些关键位置都加入了日志机制，产生事件。观察者监控事件流，对数据进行处理。Chrome中已有的观察者有：</p>

<ul>
<li>(net_log_logger.cc) 将事件流序列化到文件</li>
<li>(net_internals_ui.cc) 将事件传递到Javascript应用程序chrome://net-internals,改应用程序可以将数据可视化展现，也可以导出到文件</li>
</ul>


<h2>NetLog的设计理念：</h2>

<ul>
<li>NetLog缺省关闭</li>
<li>NetLog关闭时不会影响性能</li>
<li>Chrome官方发行版本支持NetLog</li>
<li>事件容易序列化/反序列化到磁盘</li>
<li>NetLog仅仅用作记录日志</li>
</ul>


<p>也就是说，日志如何序列化，如何分析并非NetLog需要关心的事情。此外，不要通过NetLog获取内部网络信息，比如为NetLog增加一个观察者得到内部网络状态信息。正确的做法是为NetworkDelegate增加接口，进行充分的测试，然后增加文档进行说明。</p>

<h2>NetLog事件的结构定义</h2>

<p>C++中NetLog事件用net::NetLog::Entry定义，这是在内存中的表示，非常容易序列化到JSON。</p>

<p>不到必要的时候，NetLog事件并不会序列化到JSON。在需要序列化事件时，JSON格式如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;">字段 </th>
<th style="text-align:center;"> 类型 </th>
<th style="text-align:left;"> 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">time </td>
<td style="text-align:center;"> string </td>
<td style="text-align:left;">事件发生的时间（毫秒)，这是时间滴答数而不是unix时间戳. 尽管这是一个数字域，使用字符串表示是避免精度损失</td>
</tr>
<tr>
<td style="text-align:center;">type </td>
<td style="text-align:center;"> number </td>
<td style="text-align:left;">事件类型的ID，枚举值定义在<a href="http://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_log_event_type_list.h?view=markup">net_log_event_type_list.h</a></td>
</tr>
<tr>
<td style="text-align:center;">source </td>
<td style="text-align:center;"> object </td>
<td style="text-align:left;">产生事件的实例，比如可以标识出某个特定的URLRequest</td>
</tr>
<tr>
<td style="text-align:center;">phase </td>
<td style="text-align:center;"> number </td>
<td style="text-align:left;">BEGIN, END, NONE三个枚举值之一</td>
</tr>
<tr>
<td style="text-align:center;">params </td>
<td style="text-align:center;"> object </td>
<td style="text-align:left;">可选字段</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
</feed>
