<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 放飞梦想]]></title>
  <link href="http://mogoweb.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://mogoweb.github.io/"/>
  <updated>2014-06-10T22:56:32+08:00</updated>
  <id>http://mogoweb.github.io/</id>
  <author>
    <name><![CDATA[mogoweb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于chromium_webview项目]]></title>
    <link href="http://mogoweb.github.io/blog/2014/06/10/about-chromium-webview-project/"/>
    <updated>2014-06-10T08:56:06+08:00</updated>
    <id>http://mogoweb.github.io/blog/2014/06/10/about-chromium-webview-project</id>
    <content type="html"><![CDATA[<p>chromium_webview的目标是在chromium核心的基础上提供Android WebView API全兼容的接口，希望达到的效果是基于Android WebView API开发的应用程序，只需将android.webkit包名替换为com.mogoweb.chrome即可完成从WebKit内核到Chromium内核的迁移。目标支持平台为Android 4.0以上。项目地址：<a href="https://github.com/mogoweb/chromium_webview">https://github.com/mogoweb/chromium_webview</a>。</p>

<h2>项目的起源</h2>

<p>从2011年开始，我转向从事chromium的定制化工作。2012年在移动手机平台上开发了一款浏览器Browser1.0，基于WebKit内核和Android WebView API。2012年下半年开始进行chromium的移植工作，其时google发布了Chrome for Android的第一个版本V0.16，还是beta版本。虽然浏览器的内核发生了很大的变化，但是我们期望上层的代码不需要做修改，于是在Content API的基础上，按照Android WebView API进行接口封装。最后做出来的浏览器美其名曰“双内核”，也就是WebKit加Chromium双内核。</p>

<!--more-->


<p>由于Chromium渲染架构的缘故，在Content API之上封装的WebView API还存在问题：</p>

<ol>
<li>为了启用硬件加速，chromium for android引入了SurfaceView，但SurfaceView动态添加会引起黑屏。所以SurfaceView必须在应用程序的初始化代码中添加，不能象Android WebView那样随心所欲的使用。</li>
<li>采用了多进程架构，后果之一就是内存狂飙，更让人难以接受的是，访问新浪首页这样复杂的网页，还不如WebKit浏览器流畅。</li>
</ol>


<p>在我们移植chromium的同时，google的工程师也没闲着，chromium代码下面开始出现android_webview的代码，接着代码越来越多，更新的也越来越频繁。有一天，在github上看到一个项目：<a href="https://github.com/pwnall/chromeview">ChromeView Project</a>。这正是我所需要的基于chromium的WebView API封装,但这哥们估计也没啥闲功夫，项目好久都没有更新。于是我就在github上创建了chromium_webview项目，早期的AwContents实现是软件渲染，所以效率低下。</p>

<p>时间推到2013年11月，Android 4.4发布，其中很大的一个变化就是使用chromium替换了原来的webkit引擎。于是我又开始哼哧哼哧研究起AOSP中的Chromium WebView实现，研究了AOSP中的Chromium WebView实现后，定下了如下策略：</p>

<ol>
<li>照搬WebViewChromium及相关代码，如果代码中使用了未公开的API，使用反射机制实现。</li>
<li>启用光栅化位图，消除对GraphicBuffer的依赖，从而不依赖系统的未公开C++接口。</li>
</ol>


<p>经过一段时间的工作，chromium webview项目终于完整支持硬件加速。</p>

<h2>Chromium WebView的应用场景</h2>

<p>有人要说了，现在Android系统都已经采用chromium引擎了，你还费老大劲整出这玩意儿，是不是吃饱了撑了。的确，做这个事情没给我带来一毛钱经济上的收益，反而搭进了我的业余休息时间，我做这件事的动力来自：</p>

<ol>
<li>Android WebView采用chromium引擎不假，但那也得4.4及以上的版本。</li>
<li>使用系统的WebView，失去了定制能力，比如要添加一个HTML标签就比较难。</li>
<li>提高水平，结交朋友。</li>
</ol>


<p>早些年做《无线城市》项目时，就发现Hybrid App还是有一些市场的。但使用系统的WebView可能存在性能低下、兼容性不良、无法定制的问题。所以chromium webview的最佳应用场景就是集成到APP作为渲染引擎，此外开发浏览器也是一个选择。</p>

<h2>Chromium WebView存在的问题</h2>

<p>Chromium WebView刚完成了初步的移植，问题还非常多，在后续的时间，将会继续完善。目前看来，仍然有几大难题难以解决：</p>

<ol>
<li>Android Library不支持包含资源，所以一些chromium资源，比如对话框等，必须手动的添加到主项目中，不太方便；</li>
<li>光栅花位图的效率似乎比GraphicBuffer的效率低一些，长网页或复杂网页在快速滚动时，会出现短暂的白屏。</li>
</ol>


<h2>后续计划</h2>

<ol>
<li>完善Chromium WebView API，修复BUG</li>
<li>开启WebGL支持</li>
<li>精简内核，优化内存占用</li>
<li>将开源浏览器TintBrowser改成使用Chromium WebView，证明基于WebView API的应用能够无缝迁移到Chromium WebView。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium网络加载速度研究(2)]]></title>
    <link href="http://mogoweb.github.io/blog/2014/04/03/chromium-loading-spped-research-1/"/>
    <updated>2014-04-03T18:10:06+08:00</updated>
    <id>http://mogoweb.github.io/blog/2014/04/03/chromium-loading-spped-research-1</id>
    <content type="html"><![CDATA[<p>本文主要内容翻译自chromium的文档<a href="http://www.chromium.org/developers/design-documents/network-stack/netlog">NetLog: Chrome’s network logging system</a>，如果您觉得文章写的不明白，请参看原文。</p>

<p>通过&lt;&lt;<a href="http://mogoweb.github.io/blog/2014/03/18/chromium-loading-speed-research-0/">Chromium网络加载速度研究(1)</a>>>这篇文章的分析，可以得出结论，云端加速是高富帅的玩法。对于个人开发者和小公司而言，是没有那个实力去部署强大的数据中心的。所以接下来还得继续研究，看看有没有其它的途径提高网页加载速度。在着手优化之前，我们需要一个profiling手段找出瓶颈，有目的的优化。另一方面，也需要考虑如何评估优化的效果。如果没有一个客观的评估，优化方案是否有效心中就没有底。谈到Profiling，大多数人估计都会想到log大法，就是在程序的一些关键位置打上log。log通常包括时间、事件、状态等。在chromium中，开发人员早就预料了此类需求，设计了一套强大的NetLog。下面就分析一下chromium中NetLog的设计、实现及其用法。</p>

<!--more-->


<h2>概述</h2>

<p>NetLog是一套为Chrome网络栈而设计的事件日志机制，帮助调试问题和分析性能。它遵照"抓取->转储->分析"的工作流程，这点和某些工具，如tcpdump有些相像。</p>

<p>典型的使用场景为：</p>

<ol>
<li> 用户启用网络日志</li>
<li> 用户重现问题</li>
<li> 用户将日志上传到BUG报告系统</li>
<li> 开发人员分析日志，定位问题</li>
</ol>


<p>在chrome网络栈内部，在一些关键位置都加入了日志机制，产生事件。观察者监控事件流，对数据进行处理。Chrome中已有的观察者有：</p>

<ul>
<li>(net_log_logger.cc) 将事件流序列化到文件</li>
<li>(net_internals_ui.cc) 将事件传递到Javascript应用程序chrome://net-internals,改应用程序可以将数据可视化展现，也可以导出到文件</li>
</ul>


<h2>NetLog的设计理念：</h2>

<ul>
<li>NetLog缺省关闭</li>
<li>NetLog关闭时不会影响性能</li>
<li>Chrome官方发行版本支持NetLog</li>
<li>事件容易序列化/反序列化到磁盘</li>
<li>NetLog仅仅用作记录日志</li>
</ul>


<p>也就是说，日志如何序列化，如何分析并非NetLog需要关心的事情。此外，不要通过NetLog获取内部网络信息，比如为NetLog增加一个观察者得到内部网络状态信息。正确的做法是为NetworkDelegate增加接口，进行充分的测试，然后增加文档进行说明。</p>

<h2>NetLog事件的结构定义</h2>

<p>C++中NetLog事件用net::NetLog::Entry定义，这是在内存中的表示，非常容易序列化到JSON。</p>

<p>不到必要的时候，NetLog事件并不会序列化到JSON。在需要序列化事件时，JSON格式如下：</p>

<table>
<thead>
<tr>
<th align="center"> 字段 </th>
<th align="center"> 类型 </th>
<th align="left"> 描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"> time </td>
<td align="center"> string </td>
<td align="left">事件发生的时间（毫秒)，这是时间滴答数而不是unix时间戳. 尽管这是一个数字域，使用字符串表示是避免精度损失</td>
</tr>
<tr>
<td align="center"> type </td>
<td align="center"> number </td>
<td align="left">事件类型的ID，枚举值定义在<a href="http://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_log_event_type_list.h?view=markup">net_log_event_type_list.h</a></td>
</tr>
<tr>
<td align="center"> source </td>
<td align="center"> object </td>
<td align="left">产生事件的实例，比如可以标识出某个特定的URLRequest</td>
</tr>
<tr>
<td align="center"> phase </td>
<td align="center"> number </td>
<td align="left">BEGIN, END, NONE三个枚举值之一</td>
</tr>
<tr>
<td align="center"> params </td>
<td align="center"> object </td>
<td align="left">可选字段 </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium网络加载速度研究(1)]]></title>
    <link href="http://mogoweb.github.io/blog/2014/03/18/chromium-loading-speed-research-0/"/>
    <updated>2014-03-18T16:22:09+08:00</updated>
    <id>http://mogoweb.github.io/blog/2014/03/18/chromium-loading-speed-research-0</id>
    <content type="html"><![CDATA[<p>本文主要内容翻译自Google的文档<a href="https://developers.google.com/chrome/mobile/docs/data-compression?hl=zh-CN">Data Compression Proxy</a>，如果您觉得文章写的不明白，请参看原文。</p>

<p>对于一款浏览器而言，速度无疑是非常重要的，其中加载速度更是重中之重。UC浏览器很早就采用了云端加速技术，所以在网页加载速度方面一直很有优势。现在越来越多的浏览器，如Opera、QQ浏览器都采用了服务器端加速技术。Chrome移动版从V33开始正式支持数据压缩代理。下面就分析一下Chrome for Android所采用的数据压缩技术。</p>

<!--more-->


<h2>数据压缩代理</h2>

<p>最新的Chrome for Android支持数据压缩代理，通过Google部署的代理服务器优化网站内容，可以极大的减少数据流量。有数据表明，采用这一特性可以减少web页面大小的50%。要启用这一功能，进入Chrome浏览器的菜单"设置->带宽管理->减少数据流量消耗"，然后打开即可。</p>

<h2>实现原理</h2>

<p>最核心的优化，减少数据大小，是由Google服务器实现的。当开启了"数据压缩代理"特性时，Chrome在手机和运行于Google数据中心的服务器之间建立连接，所有非加密的HTTP请求都通过该连接中转。</p>

<p><img src="http://mogoweb.qiniudn.com/mogoweb_2014_compression-proxy.png" alt="Data Compression Proxy" /></p>

<p>代理服务器收到手机发起的请求后，向目标网站发起请求，对每个回应进行优化，再回给手机。内容优化是通过Google的开源库<a href="https://developers.google.com/speed/pagespeed/">PageSpeed</a>实现的，该库针对Chrome移动浏览器进行了特别的微调。网页的渲染、JavaScript执行，是由手机上的Chrome浏览器完成的。</p>

<ul>
<li>HTTPS连接不通过数据压缩代理</li>
<li>使用数据压缩代理不需要Google账号</li>
<li>匿名窗口中的浏览不经过数据压缩代理</li>
</ul>


<p>如果您对压缩代理节省的带宽表示怀疑，可以进入到浏览器设置中查看浏览器接收数据的原始大小和优化大小的对比图。如下图所示，带宽节省增长很快。</p>

<p><img src="http://mogoweb.qiniudn.com/mogoweb_2014_bandwidth-usage.png" alt="bandwidth usage" /></p>

<p>让我们近距离观察一下压缩代理进行了那些特别的优化。</p>

<h3>SPDY</h3>

<p>从手机到代理服务器会尽力采用SPDY, 这是一个针对Web优化的协议，得到了Chrome/Firefox和Opera的支持，也是即将到来的HTTP/2.0标准的基础。如果SPDY连接无法创建，则会建立一个普通的HTTP/1.1代理连接。</p>

<p><img src="http://mogoweb.qiniudn.com/mogoweb_2014_http-https.png" alt="http-https" /></p>

<p>使用SPDY协议，代理服务器可以在一个TCP连接上同时复用多个请求和回应，这样做有很大的好处：它可以分摊多个请求的TCP握手开销。去掉每个请求的TCP慢速启动阶段，提高吞吐量，还能在数据流上智能的定义请求和回应优先级。事实上，研究表明仅仅使用SPDY可以减少移动网络下23%的页面加载时间，这还没有将内容优化算在内。</p>

<p>此外，使用数据压缩代理还有许多其它的好处：</p>

<ul>
<li>DNS延迟绑定：DNS查找由代理服务器执行，而不是由手机，这样查找过程可以快很多。</li>
<li>更少的网络活动和更快的加载速度意味着移动射频活动期更短（减少电量消耗）</li>
</ul>


<h3>内容优化</h3>

<p>悲剧的是，大多数网站并没有对移动终端进行优化，导致内容加载低效和渲染慢。PageSpeed的经验表明，许多内容的优化可以自动完成，就如同数据压缩代理所做的。</p>

<p><em>图片转码:</em> 平均下来，每个页面60%的传输数据是图片。为此，代理服务器特别对此进行优化，将所有的图片都转码为<a href="https://developers.google.com/speed/webp/">WebP</a>格式。WebP比当前流行的格式，如JPEG和PNG，数据量更小。代理支持最新的WebP无损格式，并根据设备分辨率和像素密度对每个图像进行优化。综合各种方法，图像大小可以减少80%。</p>

<p><em>内容压缩:</em> 代理智能的压缩和缩减HTML、JavaScript和CSS资源，通过移除不必要的空格、注释以及其它与页面渲染无关的元数据，再加上对所有资源启用gzip压缩，可以极大的节约带宽。</p>

<p><em>安全浏览:</em> 代理实现了移动Chrome浏览器上的<a href="http://blog.chromium.org/2012/01/all-about-safe-browsing.html">安全浏览</a>，当您访问恶意或者钓鱼网站时会告之浏览器，浏览器会显示一个警告页面。恶意网站列表由代理持续更新。</p>

<h2>该采用云加速技术吗？</h2>

<p>通过前面的分析，采用数据压缩代理似乎是个不错的方案，但是从图1可以看出，所有的数据都需要通过数据压缩代理中转，这就要求：</p>

<ul>
<li>拥有强大的服务器，快速的进行数据压缩</li>
<li>拥有强大的数据中心，否则瓶颈会存在于数据压缩代理</li>
<li>拥有强大的分布式计算能力，浏览器终端需要能够就近连接数据压缩代理</li>
</ul>


<p>在中国，Chrome for Android如果开启数据压缩代理功能，速度反而更慢，其原因就在于Google在中国并没有部署服务器。对于个人开发者和中小企业，一来无法部署强大的数据中心，二来也无法使用Google的服务，所以服务器端加速方案不具备可行性。</p>
]]></content>
  </entry>
  
</feed>
