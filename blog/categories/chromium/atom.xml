<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: chromium | 放飞梦想]]></title>
  <link href="http://mogoweb.net/blog/categories/chromium/atom.xml" rel="self"/>
  <link href="http://mogoweb.net/"/>
  <updated>2015-11-25T11:41:39+08:00</updated>
  <id>http://mogoweb.net/</id>
  <author>
    <name><![CDATA[mogoweb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于chromium for android开发Android浏览器]]></title>
    <link href="http://mogoweb.net/blog/2015/11/03/develop-android-browser-base-on-chromium-for-android/"/>
    <updated>2015-11-03T08:39:21+08:00</updated>
    <id>http://mogoweb.net/blog/2015/11/03/develop-android-browser-base-on-chromium-for-android</id>
    <content type="html"><![CDATA[<p>在上一篇文章&lt;&lt; <a href="http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source/">Chromium for Android开源了</a> >>中谈到了Google已经完全开源了Chromium for Android，这样我们就完全可以开发与Chrome for Android媲美的Android浏览器了。通常浏览器的一些新特性和新功能会先出现在Chromium for Android上，稳定后才会出现在Chrome for Android上，如果我们基于Chromium for Android开发浏览器产品，在新特性和新功能方面不会落后于Chrome浏览器.</p>

<p>Chromium开源项目的代码及其庞大，也相当的复杂。对于Android开发人员，特别是UI开发人员来说，没有一个合适的IDE环境，会是一个非常痛苦的事情。我们通常是这样开发的，在sublime text中阅读、修改代码，使用chromium的构建系统build出apk，安装到手机，进行调试。对于native代码来说，这样的开发方式也不会有太多麻烦，因为native部分的代码通常修改很少。但如果主要进行UI的定制，这种开发方式就非常痛苦了。</p>

<p>为了应对这个问题，考虑如下方案：</p>

<ol>
<li>采用Android Studio作为开发环境，从Chromium for Android抽取chrome模块的源码，加入Android project。</li>
<li>native代码在chromium环境中build，作为so加入Android project</li>
<li>基础模块(base, content, net等)在chromium环境build为jar包，加入Android project</li>
<li>content, chrome, ui等模块的资源文件加入Android library project</li>
</ol>


<p>资源文件为什么不能直接都添加到Android project呢？因为命名空间的原因，比如content模块的资源的命名空间为org.chromium.content, chrome模块的资源的命名空间为org.chromium.chrome，所以需要建立不同的Android library project, 指定不同的包名。最后整个项目的结构如下：</p>

<pre><code>browser
  |_ app
  |    |_ libs
  |    |_ src
  |         |_ main
  |              |_ aidl
  |              |_ assets
  |              |_ java
  |              |_ jniLibs
  |              |_ res
  |_ libraries
       |_ androidmedia_res
       |_ chrome_res
       |_ content_res
       |_ datausagechart_res
       |_ ui_res
</code></pre>

<p>注意事项：</p>

<ol>
<li>chromium项目的源码和资源有些是自动生成的，需要到out目录下去复制</li>
<li>pak和dat等文件需要加入到assets目录，而且不能压缩</li>
<li>aidl文件加入到main/aidl下，android studio会自动处理</li>
</ol>


<p>实践证明，这种方案是行之有效的，请参考github上的项目: <a href="https://github.com/mogoweb/365browser">365browser</a>。在script目录下有从chromium项目同步代码和资源的脚本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium for Android开源了]]></title>
    <link href="http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source/"/>
    <updated>2015-09-25T09:08:49+08:00</updated>
    <id>http://mogoweb.net/blog/2015/09/25/chromium-for-android-already-open-source</id>
    <content type="html"><![CDATA[<p>最近一段时间都在忙其它的事情，没有关注chromium的最新进展。这几天浏览 <a href="http://www.chromium.org">http://www.chromium.org</a> 上的文档，发现android build目标增加了一个：chrome_public_apk。编译方法：</p>

<blockquote><h1>Build the full browser</h1>

<p>~/chromium/src$ ninja -C out/Release chrome_public_apk</p>

<p>~/chromium/src$ build/android/adb_install_apk.py out/Release/apks/ChromePublic.apk</p></blockquote>

<p>搜索了一下相关新闻，大约在2015年5月份开始，chromium中开始加入了chrome for android的源码。从2012年开始，chromium中开始出现Android的移植代码，但只有Content API和ContentShell，离一个完备的浏览器还有一定的距离。当然，基于Content API开发浏览器也是可行的，当年就是这么干的。Chromium for Android和Chrome for Android并非完全一样，就如同桌面版Chromium浏览器和Chrome浏览器之间的区别。</p>

<p>下面放上一些Chromium for Android浏览器的截图，慢慢品味吧：</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_welcome.png" alt="welcome" /></p>

<p>欢迎界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_account.png" alt="account" /></p>

<p>帐号同步界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_main.png" alt="main" /></p>

<p>浏览器主界面</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_menu.png" alt="menu" /></p>

<p>浏览器菜单</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_settings.png" alt="settings" /></p>

<p>浏览器设置</p>

<p><img src="http://7d9je4.com1.z0.glb.clouddn.com/mogoweb_2015_chromium_for_android_tabs.png" alt="tabs" /></p>

<p>浏览器标签页</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何打印gyp构建系统中的变量值]]></title>
    <link href="http://mogoweb.net/blog/2015/06/30/how-to-print-variable-of-gyp/"/>
    <updated>2015-06-30T14:16:51+08:00</updated>
    <id>http://mogoweb.net/blog/2015/06/30/how-to-print-variable-of-gyp</id>
    <content type="html"><![CDATA[<p>chromium项目使用了gyp构建系统，gyp的全称是&#8221;Generate Your Projects&#8221;。gyp构建系统使用的并不广泛，目前已知的只有chromium开源项目采用了这一构建系统。官方虽然也有一些文档，但都是一些比较基础的指南，总体来说缺少详细的文档来指导开发人员在项目中使用。
因为研究chromium的缘故，所以对gyp构建系统也有一些了解，在使用中也碰到一些问题，本文所要探讨的是如何输出gyp的变量值。这个问题的场景是这样的：在gyp中定义了变量，但是经过多重gypi包含，在别的gyp文件中可能对变量值进行了赋值。处于调试目的，我们希望输出gyp变量的值。</p>

<p>方法看起来很简单，但也摸索了很久。方法如下，在gyp中合适的位置加入如下代码：</p>

<pre><code>'variables': {
  'mytest': '&lt;!(echo &lt;(variable) 1&gt;&amp;2)',
}
</code></pre>

<p>其中&#8217;mytest&#8217;是我随便定义的一个变量值，variable是希望打印的gyp变量。比如以下语句：</p>

<pre><code>'variables': {
  'mytest': '&lt;!(echo &lt;(OS) 1&gt;&amp;2)',
}
</code></pre>

<p>输出如下结果：</p>

<pre><code>Updating projects from gyp files...
android
gyp: Call to 'echo android 1&gt;&amp;2' returned exit status 0.
</code></pre>

<p>从上面的输出可以看出，OS的变量值为android。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Chromium for Android中能否用TextureView替代SurfaceView]]></title>
    <link href="http://mogoweb.net/blog/2015/06/19/using-textureview-instead-of-surfaceview-in-chrome-for-android/"/>
    <updated>2015-06-19T19:26:45+08:00</updated>
    <id>http://mogoweb.net/blog/2015/06/19/using-textureview-instead-of-surfaceview-in-chrome-for-android</id>
    <content type="html"><![CDATA[<p>在开发Browser 2.0时，碰到一个非常头疼的问题，往布局上添加SurfaceView时，会引起黑屏闪一下。为了解决这个问题，我们不得不在初始化阶段就把SurfaceView添加好，之后也不能调整大小、移动位置。当时就考虑是不是能够用TextureView替代SurfaceView，不过由于计划上的调整，没有做进一步的尝试。今天在网上看到<a href="https://github.com/crosswalk-project/crosswalk-website/wiki/Android-SurfaceView-vs-TextureView">这篇文章</a>，正好解答了我的疑问，在此把文章翻译过来，供参考。</p>

<blockquote><h1>Android SurfaceView和textureView</h1>

<p>本文将简要介绍SurfaceView和TextureView的不同之处</p>

<h2>SurfaceView和TextureView</h2>

<p>SurfaceView和TextureView都继承自android.view.View类，他们都可以在另一个独立线程中绘制和渲染，这是和其它View的最大不同。Crosswalk采用这一分离绘制特性，独立的GPU线程显著提高了渲染效率。</p>

<p>SurfaceView提供一个嵌入在视图层次上的专用绘制表面，您可以控制该表面（Surface）的格式和尺寸。SurfaceView负责将表面放置在屏幕上正确的位置。它的行为多少有些类似于传统桌面系统上的onscreen窗口，比如，X11系统中的XWindow可以是无边框的，嵌入在另一个XWindow中。</p>

<p>SurfaceView存在如下两个缺点：</p>

<ul>
<li>不能应用动画、变换和缩放</li>
<li>不能叠加（Overlay）两个SurfaceView</li>
</ul>


<p>TextureView看似更像一个通用的View，可以应用动画、变换和缩放，就如同TextView。TextureView只能用在硬件加速的窗口。但是，TextureView比SurfaceView更耗内存，而且可能会有1～3帧的延迟，请参考讨论<a href="https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4">3</a>。</p>

<h2>使用可以动画的XWalkView</h2>

<p>Crosswalk Embedding API for Android很好的支持了SurfaceView和TextureView。XWalkView缺省使用SurfaceView，也允许您在以下情况下使用TextureView：</p>

<ul>
<li>您想让XWalkView支持动画和变换</li>
<li>您想叠加两个XWalkView</li>
</ul>


<p>设置布尔标识ANIMATIBLE_XWALK_VIEW为true即可启用TextureView。</p>

<ol>
<li><a href="http://developer.android.com/reference/android/view/SurfaceView.html">http://developer.android.com/reference/android/view/SurfaceView.html</a></li>
<li><a href="http://developer.android.com/reference/android/view/TextureView.html">http://developer.android.com/reference/android/view/TextureView.html</a></li>
<li><a href="https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4">https://groups.google.com/a/chromium.org/forum/#!topic/graphics-dev/Z0yE-PWQXc4</a></li>
</ol>
</blockquote>

<p>文中提到的讨论起源是在google groups中有人提出如下问题：</p>

<blockquote><p>在当前ContentViewRenderView实现中，使用SurfaceView作为合成表面(compositing surface)，如我们所知，SurfaceView是一个特别的视图，无法进行动画或者变换。</p>

<p>TextureView可以做SufaceView同样的事情，比如，您可以在另一个独立线程中渲染，也可以从底下的SurfaceTexture创建一个egl表面(eglSurface)。更主要的是，TextureView可以进行动画和变换。</p>

<p>我很好奇为什么不使用TextureView作为合成表面，是否TextureView在使用上有一些特别的考虑，比如性能问题？欢迎任何讨论。</p></blockquote>

<p>Google groups有人做如下回复：</p>

<blockquote><p>事实上chrome过去使用TextureView作为合成表面，但我们出于几个原因切换到SurfaceView：</p>

<ul>
<li>由于失效(invalidation)和缓冲的特性，TextureView增加了额外1~3帧的延迟显示画面更新</li>
<li>TextureView总是使用GL合成，而SurfaceTexture可以使用硬件overlay后端，可以占用更少的内存带宽，消耗更少的能量</li>
<li>TextureView的内部缓冲队列导致比SurfaceView使用更多的内存</li>
<li>TextureView的动画和变换能力我们用不上</li>
</ul>
</blockquote>

<p>所以结论是Chromium for Android中可以使用TextureView替代SurfaceView作为合成表面，但带来的后果是占用更多的内存，性能下降。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Ubuntu菜单项中的%U参数]]></title>
    <link href="http://mogoweb.net/blog/2015/03/11/about-percent-u-paramters-in-ubuntu-menu-entry/"/>
    <updated>2015-03-11T16:05:57+08:00</updated>
    <id>http://mogoweb.net/blog/2015/03/11/about-percent-u-paramters-in-ubuntu-menu-entry</id>
    <content type="html"><![CDATA[<p>今天在研究chromium deb打包的时候，发现Google Chrome deb包中的/usr/share/applications/google-chrome.desktop文件定义入口为：
<code>
Exec=/usr/bin/google-chrome-stable %U
</code>
这个%U参数是做什么用的呢？查找了一下资料，有如下描述：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>%u A single URL. Local files may either be passed as file: URLs or as file path.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;%U A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.</span></code></pre></td></tr></table></div></figure>
也就是说，加入了%U参数，可以传递多个URL给Chrome浏览器，浏览器会依次打开各URL。比如您在文件管理器中选择了多个html文件，然后在鼠标右键菜单中点击&#8221;Open with Google Chrome&#8221;，Chrome浏览器就会依次打开所选的网页。</p>

<p>以下是Exec支持的参数说明，来自<a href="http://standards.freedesktop.org/desktop-entry-spec/latest/ar01s06.html">http://standards.freedesktop.org/desktop-entry-spec/latest/ar01s06.html</a>:
<code>
Code    Description
%f  A single file name, even if multiple files are selected. The system reading the desktop entry should recognize that the program in question cannot handle multiple file arguments, and it should should probably spawn and execute multiple copies of a program for each selected file if the program is not able to handle additional file arguments. If files are not on the local file system (i.e. are on HTTP or FTP locations), the files will be copied to the local file system and %f will be expanded to point at the temporary file. Used for programs that do not understand the URL syntax.
%F  A list of files. Use for apps that can open several local files at once. Each file is passed as a separate argument to the executable program.
%u  A single URL. Local files may either be passed as file: URLs or as file path.
%U  A list of URLs. Each URL is passed as a separate argument to the executable program. Local files may either be passed as file: URLs or as file path.
%d  Deprecated.
%D  Deprecated.
%n  Deprecated.
%N  Deprecated.
%i  The Icon key of the desktop entry expanded as two arguments, first --icon and then the value of the Icon key. Should not expand to any arguments if the Icon key is empty or missing.
%c  The translated name of the application as listed in the appropriate Name key in the desktop entry.
%k  The location of the desktop file as either a URI (if for example gotten from the vfolder system) or a local filename or empty if no location is known.
%v  Deprecated.
%m  Deprecated.
</code></p>
]]></content>
  </entry>
  
</feed>
